using System.Linq;
using System.Numerics;
using Content.Shared.Ghost;
using Content.Shared._RMC14.TacticalMap;
using Content.Shared.Damage;
using Content.Shared.Mobs;
using Content.Shared.Mobs.Components;
using Content.Shared.Mobs.Systems;
using Content.Shared._RMC14.Marines;
using Content.Shared._RMC14.Xenonids;
using Content.Shared._RMC14.Survivor;
using Content.Shared.Follower;
using Content.Shared.NPC.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;
using Robust.Client.Graphics;
using Content.Client.UserInterface.ControlExtensions;
using Content.Shared._RMC14.Marines.Squads;
using Content.Shared._RMC14.Ghost;
using Robust.Shared.Prototypes;

namespace Content.Client._RMC14.UserInterface.Systems.Ghost.Controls
{
    [GenerateTypedNameReferences]
    public sealed partial class RMCGhostTargetWindow : DefaultWindow
    {
        [Dependency] private readonly EntityManager _entityManager = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

        private static readonly Dictionary<string, int> NameCounters = new();

        private sealed class WarpGroup
        {
            /// <summary> RMC14: This is the title of the group. Is a table of contents for the title of the collapsible. </summary>
            /// <remarks>
            /// Type is not LocID for working with squad entities, but I will PERSONALLY CURSE YOU if you don't use a localization key when it's possible.
            /// </remarks>
            public required string Title;

            /// <summary> RMC14: List of warp targets in the group. </summary>
            public List<(string displayName, NetEntity Entity, bool IsWarpPoint, string? DisplayJob)> Warps = new();

            /// <summary> RMC14: Color of the header of the collapsible. </summary>
            public Color HeaderColor = Color.FromHex("#696969"); // #696969

            /// <summary> RMC14: Whether the collapsible is expanded by default. </summary>
            public bool IsExpandedByDefault = true;

            /// <summary> RMC14: List of subgroups in the group. </summary>
            public List<WarpGroup>? Subgroups;
        }

        private List<WarpGroup> _warpGroups = new();
        private readonly Dictionary<Collapsible, WarpGroup> _collapsibleGroups = new();
        private string _searchText = string.Empty;

        public event Action<NetEntity>? WarpClicked;
        public event Action? OnGhostnadoClicked;

        public RMCGhostTargetWindow()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);
            SearchBar.OnTextChanged += OnSearchTextChanged;

            GhostnadoButton.OnPressed += _ => OnGhostnadoClicked?.Invoke();
        }

        /// <summary>
        /// RMC14: This method is responsible for populating groups and subgroups with warp targets.
        /// If you want to add new groups or subgroups you only need to change this method.
        /// </summary>
        /// <remarks>
        /// <para>
        /// <para>To add a new group:</para>
        /// 1. Create a new WarpGroup instance (e.g., var myGroup = new WarpGroup { Title = "my-loc-id" };).
        /// 2. Add logic to populate myGroup.Warps with entries.
        /// 3. Add the new group to the _warpGroups list (e.g., _warpGroups.Add(myGroup);).
        /// </para>
        /// <para>
        /// <para>To add a new subgroup to an existing group:</para>
        /// 1. Find the parent group (e.g., var parentGroup = _warpGroups.Find(g => g.Title == "rmc-ghost-target-window-group-marines");).
        /// 2. Check if parentGroup.Subgroups is null and initialize it if needed.
        /// 3. Create the subgroup WarpGroup instance.
        /// 4. Add logic to populate the subgroup's Warps.
        /// 5. Add the subgroup to the parent's list (parentGroup.Subgroups.Add(mySubgroup);).
        /// </para>
        /// </remarks>
        public void UpdateWarps(IEnumerable<GhostWarp> warps)
        {
            _warpGroups.Clear();
            var mobState = _entityManager.System<MobStateSystem>();
            var squadSystem = _entityManager.System<SquadSystem>();
            var npcFactionSystem = _entityManager.System<NpcFactionSystem>();

            // --- Custom groups (RMCGhostWarpGroup) ---
            var allGroupProtos = new Dictionary<string, RMCGhostWarpGroupPrototype>();

            // Debug: Check if prototypes are loaded
            var prototypeCount = _prototypeManager.Count<RMCGhostWarpGroupPrototype>();
            Logger.Debug($"RMCGhostWarpGroupPrototype count: {prototypeCount}");

            // Debug: Check if prototype kind is registered
            var hasKind = _prototypeManager.HasKind("RMCGhostWarpGroup");
            Logger.Debug($"RMCGhostWarpGroup kind registered: {hasKind}");

            // Debug: List all registered prototype kinds
            var allKinds = _prototypeManager.GetPrototypeKinds();
            Logger.Debug($"All registered prototype kinds: {string.Join(", ", allKinds)}");

            foreach (var proto in _prototypeManager.EnumeratePrototypes<RMCGhostWarpGroupPrototype>())
            {
                Logger.Debug($"Found RMCGhostWarpGroupPrototype: {proto.ID} - {proto.Name}");
                allGroupProtos[proto.ID] = proto;
            }

            Logger.Debug($"Total RMCGhostWarpGroupPrototype loaded: {allGroupProtos.Count}");

            var allWarpGroups = new Dictionary<string, WarpGroup>();
            var childToParent = new Dictionary<string, string>();

            // Build group tree with cycle protection
            var visited = new HashSet<string>();
            foreach (var proto in allGroupProtos.Values)
            {
                BuildGroupTree(proto.ID, allGroupProtos, allWarpGroups, childToParent, new Stack<string>());
            }

            // --- Standard groups ---
            var marines = new WarpGroup { Title = "rmc-ghost-target-window-group-marines", HeaderColor = Color.FromHex("#1c70b0") };
            var xenos = new WarpGroup { Title = "rmc-ghost-target-window-group-xenos", HeaderColor = Color.FromHex("#472f4f") };
            var others = new WarpGroup { Title = "rmc-ghost-target-window-group-others" };
            var deads = new WarpGroup { Title = "rmc-ghost-target-window-group-deads", IsExpandedByDefault = false };
            var ghosts = new WarpGroup { Title = "rmc-ghost-target-window-group-ghosts", IsExpandedByDefault = false };
            var warpPoints = new WarpGroup { Title = "rmc-ghost-target-window-group-warp-points", IsExpandedByDefault = false };

            // --- We distribute entities into groups ---
            foreach (var warp in warps)
            {
                var entry = (warp.DisplayName, warp.Entity, warp.IsWarpPoint, warp.DisplayJob);
                var entity = _entityManager.GetEntity(warp.Entity);

                // 1. Warp points
                if (warp.IsWarpPoint)
                {
                    warpPoints.Warps.Add(entry);
                    continue;
                }
                // 2. Dead
                if (mobState.IsDead(entity))
                {
                    deads.Warps.Add(entry);
                    continue;
                }
                // 3. Ghost
                if (_entityManager.HasComponent<GhostComponent>(entity))
                {
                    ghosts.Warps.Add((warp.DisplayName, warp.Entity, warp.IsWarpPoint, null));
                    continue;
                }
                // 4. Custom group (only for alive, non-ghost, non-WarpPoint)
                if (_entityManager.TryGetComponent<RMCGhostWarpGroupMemberComponent>(entity, out var groupComp) &&
                    allWarpGroups.TryGetValue(groupComp.Group, out var warpGroup))
                {
                    warpGroup.Warps.Add(entry);
                    continue;
                }
                // 5. Standard groups
                if (npcFactionSystem.IsMember(entity, "UNMC") && !_entityManager.HasComponent<RMCSurvivorComponent>(entity))
                {
                    if (squadSystem.TryGetMemberSquad(entity, out var squad))
                    {
                        if (marines.Subgroups == null)
                            marines.Subgroups = new List<WarpGroup>();
                        var squadName = _entityManager.GetComponent<MetaDataComponent>(squad.Owner).EntityName;
                        var squadGroup = marines.Subgroups.Find(g => g.Title == squadName);
                        if (squadGroup == null)
                        {
                            squadGroup = new WarpGroup
                            {
                                Title = squadName,
                                HeaderColor = AdjustLightness(squad.Comp.Color, -0.1f),
                                IsExpandedByDefault = true
                            };
                            marines.Subgroups.Add(squadGroup);
                        }
                        squadGroup.Warps.Add(entry);
                    }
                    else
                    {
                        if (marines.Subgroups == null)
                            marines.Subgroups = new List<WarpGroup>();
                        var othersGroup = marines.Subgroups.Find(g => g.Title == "rmc-ghost-target-window-group-others");
                        if (othersGroup == null)
                        {
                            othersGroup = new WarpGroup { Title = "rmc-ghost-target-window-group-others" };
                            marines.Subgroups.Add(othersGroup);
                        }
                        othersGroup.Warps.Add(entry);
                    }
                }
                else if (_entityManager.HasComponent<XenoComponent>(entity))
                {
                    xenos.Warps.Add(entry);
                }
                else
                {
                    others.Warps.Add(entry);
                }
            }

            // --- Add groups to _warpGroups ---
            // 1. Standard groups (marines, xenos)
            _warpGroups.Add(marines);
            _warpGroups.Add(xenos);
            // 2. Custom Root Groups (sorted alphabetically)
            var rootCustomGroups = new List<WarpGroup>();
            foreach (var (id, group) in allWarpGroups)
            {
                if (!childToParent.ContainsKey(id))
                    rootCustomGroups.Add(group);
            }
            rootCustomGroups.Sort((a, b) => string.Compare(Loc.GetString(a.Title), Loc.GetString(b.Title), StringComparison.CurrentCulture));
            foreach (var group in rootCustomGroups)
                _warpGroups.Add(group);
            // 3. Other standard groups
            _warpGroups.Add(others);
            _warpGroups.Add(deads);
            _warpGroups.Add(warpPoints);
            _warpGroups.Add(ghosts);

            // Sorting all groups and subgroups
            foreach (var group in _warpGroups)
            {
                group.Warps.Sort((a, b) => string.Compare(a.displayName, b.displayName, StringComparison.CurrentCulture));
                if (group.Subgroups != null)
                {
                    group.Subgroups.Sort((a, b) =>
                    {
                        const string othersKey = "rmc-ghost-target-window-group-others";
                        if (a.Title == othersKey && b.Title != othersKey)
                            return 1;
                        if (b.Title == othersKey && a.Title != othersKey)
                            return -1;
                        var aLoc = Loc.GetString(a.Title);
                        var bLoc = Loc.GetString(b.Title);
                        return string.Compare(aLoc, bLoc, StringComparison.CurrentCulture);
                    });
                    foreach (var subgroup in group.Subgroups)
                    {
                        subgroup.Warps.Sort((a, b) => string.Compare(a.displayName, b.displayName, StringComparison.CurrentCulture));
                    }
                }
            }
        }

        /// <summary>
        /// RMC14: Recursively builds the group tree and protects from cycles.
        /// </summary>
        private WarpGroup? BuildGroupTree(
            string id,
            Dictionary<string, RMCGhostWarpGroupPrototype> allGroupProtos,
            Dictionary<string, WarpGroup> allWarpGroups,
            Dictionary<string, string> childToParent,
            Stack<string> path)
        {
            if (path.Contains(id))
            {
                // Cycle detected!
                var cycle = string.Join(" -> ", path) + " -> " + id;
                Logger.Error($"Cycle detected in ghost warp group prototypes: {cycle}");
                return null;
            }
            path.Push(id);
            if (!allWarpGroups.TryGetValue(id, out var group))
            {
                if (!allGroupProtos.TryGetValue(id, out var proto))
                {
                    path.Pop();
                    return null;
                }
                group = new WarpGroup
                {
                    Title = proto.Name,
                    HeaderColor = proto.Color,
                    IsExpandedByDefault = proto.IsExpandedByDefault,
                    Subgroups = null
                };
                allWarpGroups[id] = group;
            }
            if (allGroupProtos.TryGetValue(id, out var thisProto) && thisProto.Subgroups != null && thisProto.Subgroups.Count > 0)
            {
                group.Subgroups ??= new List<WarpGroup>();
                foreach (var subId in thisProto.Subgroups)
                {
                    if (childToParent.ContainsKey(subId))
                        continue;
                    var subGroup = BuildGroupTree(subId, allGroupProtos, allWarpGroups, childToParent, path);
                    if (subGroup != null)
                    {
                        group.Subgroups.Add(subGroup);
                        childToParent[subId] = id;
                    }
                }
            }
            path.Pop();
            return group;
        }

        /// <summary>
        /// RMC14: Populates the window with the current warp groups and their content.
        /// </summary>
        public void Populate()
        {
            ContentContainer.DisposeAllChildren();
            AddContent();
        }

        /// <summary>
        /// RMC14: Adds all group content (including subgroups) to the main content container.
        /// </summary>
        private void AddContent()
        {
            var spriteSystem = _entityManager.System<SpriteSystem>();
            var mobThreshold = _entityManager.System<MobThresholdSystem>();
            var mobState = _entityManager.System<MobStateSystem>();

            foreach (var group in _warpGroups)
            {
                // Проверяем, есть ли контент в группе или её подгруппах
                if (!HasContent(group))
                    continue;
                AddGroupContent(group, ContentContainer, spriteSystem, mobThreshold, mobState, false);
            }
        }

        /// <summary>
        /// RMC14: Recursively checks if a group or its subgroups have any content (warp targets).
        /// </summary>
        private bool HasContent(WarpGroup group)
        {
            // Если есть warp-цели, показываем
            if (group.Warps.Count > 0)
                return true;

            // Если есть подгруппы, проверяем их
            if (group.Subgroups != null && group.Subgroups.Count > 0)
            {
                foreach (var subgroup in group.Subgroups)
                {
                    if (HasContent(subgroup))
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// RMC14: Recursively adds collapsible UI elements for a group and its subgroups.
        /// </summary>
        private void AddGroupContent(WarpGroup group, Container parent, SpriteSystem spriteSystem, MobThresholdSystem mobThreshold, MobStateSystem mobState, bool isSubgroup)
        {
            var heading = CreateHeading(group, spriteSystem, CountAllWarps(group));
            var body = new CollapsibleBody { HorizontalExpand = true, Margin = new Thickness(0, 3, 0, 0) };

            // Main container for all content (buttons and subgroups)
            var mainContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Vertical,
                HorizontalExpand = true,
                VerticalExpand = false
            };

            // Container for buttons
            if (group.Warps.Count > 0)
            {
                var buttonGrid = CreateGroupContainer(body);
                foreach (var (name, warpTarget, isWarpPoint, job) in group.Warps)
                {
                    var button = CreateWarpButton(name, warpTarget, isWarpPoint, job, spriteSystem, mobThreshold, mobState, group, ButtonIsVisible);
                    buttonGrid.AddChild(button);
                }
                mainContainer.AddChild(buttonGrid);
            }

            // Container for subgroups
            if (group.Subgroups != null && group.Subgroups.Count > 0)
            {
                var subgroupsBox = new BoxContainer
                {
                    Orientation = BoxContainer.LayoutOrientation.Vertical,
                    HorizontalExpand = true,
                    VerticalExpand = false
                };
                foreach (var subgroup in group.Subgroups)
                {
                    // Проверяем, есть ли контент в подгруппе
                    if (HasContent(subgroup))
                    {
                        AddGroupContent(subgroup, subgroupsBox, spriteSystem, mobThreshold, mobState, true);
                    }
                }
                // Добавляем subgroupsBox только если в нём есть контент
                if (subgroupsBox.ChildCount > 0)
                {
                    mainContainer.AddChild(subgroupsBox);
                }
            }

            // Add main container to body
            body.AddChild(mainContainer);

            var collapsible = CreateCollapsible(heading, body, group, isSubgroup);
            parent.AddChild(collapsible);

            _collapsibleGroups[collapsible] = group;
        }

        /// <summary>
        /// RMC14: Recursively counts all warp targets (buttons) in a group and its subgroups.
        /// </summary>
        private int CountAllWarps(WarpGroup group)
        {
            int count = group.Warps.Count;
            if (group.Subgroups != null)
            {
                foreach (var subgroup in group.Subgroups)
                    count += CountAllWarps(subgroup);
            }
            return count;
        }

        /// <summary>
        /// RMC14: Creates a collapsible heading with a colored background and hover effect.
        /// </summary>
        private CollapsibleHeading CreateHeading(WarpGroup group, SpriteSystem spriteSystem, int totalCount)
        {
            var heading = new CollapsibleHeading($"{Loc.GetString(group.Title)} — ({totalCount})");
            heading.StyleBoxOverride = new StyleBoxTexture
            {
                Texture = spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/Nano/rounded_button.svg.96dpi.png"))),
                Modulate = group.HeaderColor,
                PatchMarginTop = 5,
                PatchMarginBottom = 5,
                PatchMarginLeft = 5,
                PatchMarginRight = 5,
                ContentMarginTopOverride = 2,
                ContentMarginLeftOverride = 5,
                ContentMarginRightOverride = 5,
                ContentMarginBottomOverride = 2,
                Padding = new Thickness(2)
            };

            heading.OnMouseEntered += _ =>
            {
                if (heading.StyleBoxOverride is StyleBoxTexture styleBox)
                {
                    styleBox.Modulate = AdjustLightness(styleBox.Modulate, 0.1f);
                }
            };

            heading.OnMouseExited += _ =>
            {
                if (heading.StyleBoxOverride is StyleBoxTexture styleBox)
                    styleBox.Modulate = group.HeaderColor;
            };

            return heading;
        }

        /// <summary>
        /// RMC14: Creates a group container (GridContainer) for a collapsible body and sets up resizing logic.
        /// </summary>
        private GridContainer CreateGroupContainer(CollapsibleBody body)
        {
            var groupContainer = new GridContainer
            {
                HorizontalExpand = true,
                VerticalExpand = true
            };
            body.OnResized += () =>
            {
                if (body.Width > 0)
                    groupContainer.MaxGridWidth = body.Width;
            };
            return groupContainer;
        }

        /// <summary>
        /// RMC14: Creates a unique button name based on base name and job, avoiding duplicates.
        /// </summary>
        private string GenerateUniqueButtonName(string baseName, string? job)
        {
            var name = job != null ? $"{baseName} {job}" : baseName;
            var uniqueName = name;

            if (!NameCounters.ContainsKey(name))
                NameCounters[name] = 0;

            while (ContentContainer.Children.OfType<Collapsible>()
                .SelectMany<Collapsible, GridContainer?>(c => c.GetChild(1) is CollapsibleBody body ? new[] { body.GetChild(0) as GridContainer } : Array.Empty<GridContainer?>())
                .Where(g => g != null)
                .SelectMany(g => g!.Children.OfType<Button>())
                .Any(b => b.Name == uniqueName))
            {
                NameCounters[name]++;
                uniqueName = $"{name} {NameCounters[name]}";
            }

            return uniqueName;
        }

        /// <summary>
        /// RMC14: Truncates the given text to a maximum length, adding ellipsis if needed.
        /// </summary>
        private string TruncateText(string text, int maxLength)
        {
            return text.Length > maxLength ? text.Substring(0, maxLength) + "..." : text;
        }

        /// <summary>
        /// RMC14: Creates a warp button for a given target, including icons and tooltip.
        /// </summary>
        private Button CreateWarpButton(string name, NetEntity warpTarget, bool isWarpPoint, string? job,
            SpriteSystem spriteSystem, MobThresholdSystem mobThreshold, MobStateSystem mobState,
            WarpGroup group, Func<Button, bool> isVisibleCheck)
        {
            var buttonContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Horizontal,
                HorizontalAlignment = Control.HAlignment.Center,
                VerticalAlignment = Control.VAlignment.Center,
                HorizontalExpand = true
            };

            float? healthPercent = null;
            if (!isWarpPoint)
                AddIconsToButtonContainer(buttonContainer, warpTarget, spriteSystem, mobThreshold, mobState, ref healthPercent);

            var label = new Label
            {
                Text = TruncateText(name, 15), // RMC14: This way we prevent the column from expanding too much, which will affect all the elements in the column.
                HorizontalAlignment = Control.HAlignment.Left,
                ClipText = false,
                Name = job != null ? $"{name} {job}" : name,
                StyleClasses = { "LabelSmall" }
            };
            buttonContainer.AddChild(label);

            if (!isWarpPoint)
                AddGhostCounter(buttonContainer, warpTarget);

            var button = new Button
            {
                Name = GenerateUniqueButtonName(name, job),
                StyleBoxOverride = new StyleBoxTexture
                {
                    Texture = spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/Nano/rounded_button.svg.96dpi.png"))),
                    PatchMarginTop = 5,
                    PatchMarginBottom = 5,
                    PatchMarginLeft = 5,
                    PatchMarginRight = 5,
                    ContentMarginTopOverride = 3,
                    ContentMarginLeftOverride = 6,
                    ContentMarginRightOverride = 6,
                    ContentMarginBottomOverride = 3,
                    Padding = new Thickness(2)
                }
            };

            if (!isWarpPoint)
                button.ToolTip = GetTooltip(warpTarget, name, job, mobState, healthPercent);

            button.AddChild(buttonContainer);
            button.OnPressed += _ => WarpClicked?.Invoke(warpTarget);
            button.Visible = isVisibleCheck(button);

            // Add effect when hovering
            button.OnMouseEntered += _ =>
            {
                if (button.StyleBoxOverride is StyleBoxTexture styleBox)
                {
                    styleBox.Modulate = AdjustLightness(styleBox.Modulate, 0.1f);
                }
            };

            button.OnMouseExited += _ =>
            {
                if (button.StyleBoxOverride is StyleBoxTexture styleBox)
                {
                    styleBox.Modulate = Color.White;
                    // For some inexplicable reason, somewhere else, something is affecting this parameter
                    // so that the mixture of the specified white color becomes #464966 and any other specified color will be significantly darkened
                }
            };

            // Add effect when pressing
            button.OnButtonDown += _ =>
            {
                if (button.StyleBoxOverride is StyleBoxTexture styleBox)
                {
                    styleBox.Modulate = Color.FromHex("#3e6c45");
                }
            };

            button.OnButtonUp += _ =>
            {
                if (button.StyleBoxOverride is StyleBoxTexture styleBox)
                {
                    styleBox.Modulate = Color.White;
                }
            };

            return button;
        }

        /// <summary>
        /// RMC14: Adds health, tactical, and other icons to the button container for a warp target.
        /// </summary>
        private void AddIconsToButtonContainer(BoxContainer buttonContainer, NetEntity warpTarget, SpriteSystem spriteSystem,
            MobThresholdSystem mobThreshold, MobStateSystem mobState, ref float? healthPercent)
        {
            var entity = _entityManager.GetEntity(warpTarget);
            if (mobState.IsCritical(entity) || mobState.IsAlive(entity))
            {
                if (_entityManager.TryGetComponent<DamageableComponent>(entity, out var damageable) &&
                    _entityManager.TryGetComponent<MobThresholdsComponent>(entity, out var thresholds))
                {
                    if (mobThreshold.TryGetThresholdForState(entity, MobState.Dead, out var deadThreshold, thresholds))
                    {
                        var maxHealth = deadThreshold.Value;
                        var currentHealth = maxHealth - damageable.TotalDamage;
                        healthPercent = (currentHealth / maxHealth).Float() * 100f;
                        string healthState;
                        if (healthPercent >= 80f)
                            healthState = "health_high";
                        else if (healthPercent >= 40f)
                            healthState = "health_medium";
                        else
                            healthState = "health_low";

                        var healthIcon = new TextureRect
                        {
                            HorizontalAlignment = Control.HAlignment.Center,
                            VerticalAlignment = Control.VAlignment.Center,
                            Texture = spriteSystem.Frame0(
                                new SpriteSpecifier.Rsi(new ResPath("/Textures/_RMC14/Interface/health_hud.rsi"), healthState)),
                            Stretch = TextureRect.StretchMode.KeepAspectCentered,
                            MinSize = new Vector2(13, 13),
                            MaxSize = new Vector2(13, 13),
                            Margin = new Thickness(0, 0, 4, 0)
                        };
                        buttonContainer.AddChild(healthIcon);
                    }
                }
            }

            if (_entityManager.TryGetComponent<TacticalMapIconComponent>(entity, out var icon) && icon.Icon != null)
            {
                var iconPanel = new PanelContainer
                {
                    Margin = new Thickness(0, 0, 4, 0)
                };

                if (icon.Background != null)
                {
                    var backgroundView = new TextureRect
                    {
                        HorizontalAlignment = Control.HAlignment.Center,
                        VerticalAlignment = Control.VAlignment.Center,
                        Texture = spriteSystem.Frame0(icon.Background),
                        Stretch = TextureRect.StretchMode.KeepAspectCentered,
                        MinSize = new Vector2(16, 16),
                        MaxSize = new Vector2(16, 16)
                    };
                    iconPanel.AddChild(backgroundView);
                }

                var iconView = new TextureRect
                {
                    HorizontalAlignment = Control.HAlignment.Center,
                    VerticalAlignment = Control.VAlignment.Center,
                    Texture = spriteSystem.Frame0(icon.Icon),
                    Stretch = TextureRect.StretchMode.KeepAspectCentered,
                    MinSize = new Vector2(16, 16),
                    MaxSize = new Vector2(16, 16)
                };
                iconPanel.AddChild(iconView);

                buttonContainer.AddChild(iconPanel);
            }
        }

        /// <summary>
        /// RMC14: Adds a ghost follower counter to the button container if the entity has followers.
        /// </summary>
        private void AddGhostCounter(BoxContainer buttonContainer, NetEntity warpTarget)
        {
            var followerSystem = _entityManager.System<FollowerSystem>();
            var entity = _entityManager.GetEntity(warpTarget);
            var followerCount = followerSystem.GetFollowerCount(entity);
            if (followerCount > 0)
            {
                var ghostCounter = new BoxContainer
                {
                    Orientation = BoxContainer.LayoutOrientation.Horizontal,
                    HorizontalAlignment = Control.HAlignment.Right,
                    VerticalAlignment = Control.VAlignment.Center,
                };

                var ghostIcon = new TextureRect
                {
                    HorizontalAlignment = Control.HAlignment.Center,
                    VerticalAlignment = Control.VAlignment.Center,
                    Texture = _entityManager.System<SpriteSystem>().Frame0(
                        new SpriteSpecifier.Rsi(new ResPath("/Textures/Mobs/Ghosts/ghost_human.rsi"), "icon")),
                    Stretch = TextureRect.StretchMode.KeepAspectCentered,
                    MinSize = new Vector2(17, 17),
                    MaxSize = new Vector2(17, 17),
                };
                ghostCounter.AddChild(ghostIcon);

                var ghostCount = new Label
                {
                    Text = followerCount.ToString(),
                    HorizontalAlignment = Control.HAlignment.Center,
                    VerticalAlignment = Control.VAlignment.Center,
                    Margin = new Thickness(2, 0, 0, 0),
                    StyleClasses = { "LabelSmall" }
                };
                ghostCounter.AddChild(ghostCount);

                buttonContainer.AddChild(ghostCounter);
            }
        }

        /// <summary>
        /// RMC14: Generates a tooltip string for a warp target, including name, job/caste, and health.
        /// </summary>
        private string GetTooltip(NetEntity warpTarget, string name, string? job, MobStateSystem mobState, float? healthPercent)
        {
            var entity = _entityManager.GetEntity(warpTarget);
            var tooltipText = $"{Loc.GetString("rmc-ghost-target-window-tooltip-name", ("name", name))}";
            if (job != null)
            {
                var isXeno = _entityManager.HasComponent<XenoComponent>(entity);
                tooltipText += isXeno
                    ? $"\n{Loc.GetString("rmc-ghost-target-window-tooltip-caste", ("caste", job))}"
                    : $"\n{Loc.GetString("rmc-ghost-target-window-tooltip-job", ("job", job))}";
            }
            if (!mobState.IsDead(entity) && healthPercent != null)
            {
                tooltipText += $"\n{Loc.GetString("rmc-ghost-target-window-tooltip-health", ("health", Math.Round(healthPercent.Value)))}";
            }

            return tooltipText;
        }

        /// <summary>
        /// RMC14: Creates a collapsible UI element for a group with a heading and body.
        /// </summary>
        private Collapsible CreateCollapsible(CollapsibleHeading heading, CollapsibleBody body, WarpGroup group, bool isSubgroup = false)
        {
            var collapsible = new Collapsible(heading, body)
            {
                Margin = isSubgroup ? new Thickness(10, 4, 0, 4) : new Thickness(0, 4),
                HorizontalExpand = true
            };

            if (group.IsExpandedByDefault)
                collapsible.BodyVisible = true;

            return collapsible;
        }


        /// <summary>
        /// RMC14: Determines if a button should be visible based on the current search text.
        /// </summary>
        private bool ButtonIsVisible(Button button)
        {
            if (string.IsNullOrEmpty(_searchText))
                return true;

            return button.Name != null && button.Name.Contains(_searchText, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// RMC14: Updates the visibility of all buttons based on the current search text.
        /// </summary>
        private void UpdateVisibleButtons()
        {
            UpdateVisibleButtonsRecursive(ContentContainer);
        }

        /// <summary>
        /// RMC14: Recursively updates the visibility of buttons in the given container based on the search text.
        /// </summary>
        private void UpdateVisibleButtonsRecursive(Container container)
        {
            foreach (var child in container.Children)
            {
                if (child is Collapsible collapsible)
                {
                    var body = collapsible.GetChild(1) as CollapsibleBody;
                    if (body == null)
                        continue;

                    // RMC14: Update buttons in all GridContainer inside body
                    foreach (var bodyChild in body.Children)
                    {
                        if (bodyChild is GridContainer groupContainer)
                        {
                            foreach (var button in groupContainer.Children.OfType<Button>())
                            {
                                button.Visible = ButtonIsVisible(button);
                            }
                        }
                        // RMC14: Recursively traverse BoxContainer with subgroups
                        else if (bodyChild is BoxContainer subgroupsBox)
                        {
                            UpdateVisibleButtonsRecursive(subgroupsBox);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// RMC14: Updates the visibility of all collapsible groups based on the current search text.
        /// </summary>
        private void UpdateVisibleCollapsibles()
        {
            UpdateVisibleCollapsibles(ContentContainer);
        }

        /// <summary>
        /// RMC14: Recursively updates the visibility of collapsible groups in the given container.
        /// </summary>
        private bool UpdateVisibleCollapsibles(Container container)
        {
            bool anyVisible = false;

            foreach (var child in container.Children)
            {
                if (child is Collapsible collapsible)
                {
                    var body = collapsible.GetChild(1) as CollapsibleBody;
                    if (body == null)
                        continue;

                    // First child — GridContainer with buttons
                    bool hasVisibleButton = false;
                    bool hasVisibleSubgroup = false;

                    foreach (var bodyChild in body.Children)
                    {
                        if (bodyChild is GridContainer buttonGrid)
                        {
                            if (buttonGrid.Children.OfType<Button>().Any(ButtonIsVisible))
                                hasVisibleButton = true;
                        }
                        else if (bodyChild is BoxContainer subgroupsBox)
                        {
                            if (UpdateVisibleCollapsibles(subgroupsBox))
                                hasVisibleSubgroup = true;
                        }
                    }

                    bool visible = hasVisibleButton || hasVisibleSubgroup;
                    collapsible.Visible = visible;
                    collapsible.BodyVisible = string.IsNullOrEmpty(_searchText)
                        ? _collapsibleGroups.TryGetValue(collapsible, out var group) && group.IsExpandedByDefault
                        : visible;

                    if (visible)
                        anyVisible = true;
                }
            }

            // Если поиск пустой — показать всё и раскрыть по умолчанию
            if (string.IsNullOrEmpty(_searchText))
            {
                foreach (var child in container.Children)
                {
                    if (child is Collapsible collapsible)
                    {
                        collapsible.Visible = true;
                        if (_collapsibleGroups.TryGetValue(collapsible, out var group))
                            collapsible.BodyVisible = group.IsExpandedByDefault;
                    }
                }
                return true;
            }

            return anyVisible;
        }

        /// <summary>
        /// RMC14: Handles the event when the search text changes, updating button and group visibility.
        /// </summary>
        private void OnSearchTextChanged(LineEdit.LineEditEventArgs args)
        {
            _searchText = args.Text;

            UpdateVisibleButtons();
            UpdateVisibleCollapsibles();
            // Reset scroll bar so they can see the relevant results.
            GhostScroll.SetScrollValue(Vector2.Zero);
        }

        /// <summary>
        /// RMC14: Adjusts the brightness of a color by a given percent.
        /// Positive percent lightens the color, negative percent darkens it.
        /// </summary>
        private static Color AdjustLightness(Color color, float percent)
        {
            var hsv = Color.ToHsv(color);
            if (percent > 0)
                hsv.Z = Math.Min(hsv.Z * (1f + percent), 1f);
            else
                hsv.Z *= (1f + percent);
            return Color.FromHsv(hsv);
        }
    }
}
