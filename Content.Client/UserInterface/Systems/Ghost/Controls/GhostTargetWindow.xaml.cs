using System.Linq;
using System.Numerics;
using Content.Shared.Ghost;
using Content.Shared._RMC14.TacticalMap;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.ResourceManagement;
using Robust.Shared.Map;
using Robust.Shared.Prototypes;
using Robust.Shared.Graphics;
using Robust.Shared.Utility;
using Robust.Client.Graphics;
using Robust.Shared.Graphics.RSI;
using Content.Client.UserInterface.ControlExtensions;

namespace Content.Client.UserInterface.Systems.Ghost.Controls
{
    [GenerateTypedNameReferences]
    public sealed partial class GhostTargetWindow : DefaultWindow
    {
        [Dependency] private readonly EntityManager _entityManager = default!;

        private List<(string, NetEntity, bool)> _warps = new();
        private string _searchText = string.Empty;

        public event Action<NetEntity>? WarpClicked;
        public event Action? OnGhostnadoClicked;

        public GhostTargetWindow()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);
            SearchBar.OnTextChanged += OnSearchTextChanged;

            GhostnadoButton.OnPressed += _ => OnGhostnadoClicked?.Invoke();
        }

        public void UpdateWarps(IEnumerable<GhostWarp> warps)
        {
            // Server COULD send these sorted but how about we just use the client to do it instead
            _warps = warps
                .OrderBy(w => w.IsWarpPoint)
                .ThenBy(w => w.DisplayName, Comparer<string>.Create(
                    (x, y) => string.Compare(x, y, StringComparison.Ordinal)))
                .Select(w =>
                {
                    var name = w.IsWarpPoint
                        ? Loc.GetString("ghost-target-window-current-button", ("name", w.DisplayName))
                        : w.DisplayName;

                    Logger.Debug($"Warp: IsWarpPoint={w.IsWarpPoint}, DisplayName={w.DisplayName}, FinalName={name}, Entity={w.Entity}");
                    return (name, w.Entity, w.IsWarpPoint);
                })
                .ToList();
        }

        public void Populate()
        {
            ButtonContainer.DisposeAllChildren();
            AddButtons();
        }

        private void AddButtons()
        {
            var spriteSystem = _entityManager.System<SpriteSystem>();

            foreach (var (name, warpTarget, isWarpPoint) in _warps)
            {
                Logger.Debug($"Creating button: name={name}, isWarpPoint={isWarpPoint}, warpTarget={warpTarget}");

                var buttonContainer = new BoxContainer
                {
                    Orientation = BoxContainer.LayoutOrientation.Horizontal,
                    HorizontalAlignment = Control.HAlignment.Center,
                    VerticalAlignment = Control.VAlignment.Center,
                    HorizontalExpand = true,
                };

                Logger.Debug($"[GHOST] Created buttonContainer: {buttonContainer.GetType().Name}");

                // Try to get icon from TacticalMapIconComponent
                if (!isWarpPoint)
                {
                    var entity = _entityManager.GetEntity(warpTarget);
                    Logger.Debug($"Getting icon for entity {entity}");
                    if (_entityManager.TryGetComponent<TacticalMapIconComponent>(entity, out var icon) && icon.Icon != null)
                    {
                        Logger.Debug($"Found icon for entity {entity}");
                        var iconPanel = new PanelContainer
                        {
                            Margin = new Thickness(0, 0, 4, 0)
                        };

                        if (icon.Background != null)
                        {
                            var backgroundView = new TextureRect
                            {
                                HorizontalAlignment = Control.HAlignment.Center,
                                VerticalAlignment = Control.VAlignment.Center,
                                Texture = spriteSystem.Frame0(icon.Background),
                                Stretch = TextureRect.StretchMode.KeepAspectCentered,
                                MinSize = new Vector2(17, 17),
                                MaxSize = new Vector2(17, 17)
                            };
                            iconPanel.AddChild(backgroundView);
                        }

                        var iconView = new TextureRect
                        {
                            HorizontalAlignment = Control.HAlignment.Center,
                            VerticalAlignment = Control.VAlignment.Center,
                            Texture = spriteSystem.Frame0(icon.Icon),
                            Stretch = TextureRect.StretchMode.KeepAspectCentered,
                            MinSize = new Vector2(17, 17),
                            MaxSize = new Vector2(17, 17)
                        };
                        iconPanel.AddChild(iconView);

                        buttonContainer.AddChild(iconPanel);
                        Logger.Debug($"[GHOST] Added icon panel to container");
                    }
                }

                var label = new Label
                {
                    Text = name,
                    HorizontalAlignment = Control.HAlignment.Left,
                    ClipText = false,
                };

                buttonContainer.AddChild(label);
                Logger.Debug($"[GHOST] Added label to container: {label.Text}");

                var button = new Button
                {
                    HorizontalExpand = true,
                };

                Logger.Debug($"[GHOST] Created button, adding container");
                button.AddChild(buttonContainer);
                Logger.Debug($"[GHOST] Button children count: {button.ChildCount}");

                button.OnPressed += _ => WarpClicked?.Invoke(warpTarget);
                button.Visible = ButtonIsVisible(button);

                ButtonContainer.AddChild(button);
            }
        }

        private bool ButtonIsVisible(Button button)
        {
            if (string.IsNullOrEmpty(_searchText))
                return true;

            Logger.Debug($"[GHOST] Search: text='{_searchText}'");
            return button.ChildrenContainText(_searchText);
        }

        private void UpdateVisibleButtons()
        {
            foreach (var child in ButtonContainer.Children)
            {
                if (child is Button button)
                    button.Visible = ButtonIsVisible(button);
            }
        }

        private void OnSearchTextChanged(LineEdit.LineEditEventArgs args)
        {
            _searchText = args.Text;
            Logger.Debug($"[GHOST] Search text changed to: '{_searchText}'");

            UpdateVisibleButtons();
            // Reset scroll bar so they can see the relevant results.
            GhostScroll.SetScrollValue(Vector2.Zero);
        }
    }
}
