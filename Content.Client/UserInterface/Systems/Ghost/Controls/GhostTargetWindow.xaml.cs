using System.Linq;
using System.Numerics;
using Content.Shared.Ghost;
using Content.Shared._RMC14.TacticalMap;
using Content.Shared.Damage;
using Content.Shared.Mobs;
using Content.Shared.Mobs.Components;
using Content.Shared.Mobs.Systems;
using Content.Shared._RMC14.Marines;
using Content.Shared._RMC14.Xenonids;
using Content.Shared.Survivor.Components;
using Content.Shared.Follower;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;
using Robust.Client.Graphics;
using Content.Client.UserInterface.ControlExtensions;

namespace Content.Client.UserInterface.Systems.Ghost.Controls
{
    /// <remarks>
    /// RMC14 the whole window has been significantly changed.
    /// Preferably NOT accepting changes in merge conflicts from upstream.
    /// </remarks>
    [GenerateTypedNameReferences]
    public sealed partial class GhostTargetWindow : DefaultWindow
    {
        [Dependency] private readonly EntityManager _entityManager = default!;

        private sealed class WarpGroup
        {
            public required LocId Title;
            public List<(string displayName, NetEntity Entity, bool IsWarpPoint, string? DisplayJob)> Warps = new();
            public Color HeaderColor = Color.FromHex("#696969");
            public bool IsExpandedByDefault = true;
        }

        private List<WarpGroup> _warpGroups = new();
        private readonly Dictionary<Collapsible, WarpGroup> _collapsibleGroups = new();
        private string _searchText = string.Empty;

        public event Action<NetEntity>? WarpClicked;
        public event Action? OnGhostnadoClicked;

        public GhostTargetWindow()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);
            SearchBar.OnTextChanged += OnSearchTextChanged;

            GhostnadoButton.OnPressed += _ => OnGhostnadoClicked?.Invoke();
        }

        public void UpdateWarps(IEnumerable<GhostWarp> warps)
        {
            _warpGroups.Clear();

            // Creating groups
            var marines = new WarpGroup { Title = new LocId("rmc-ghost-target-window-group-marines") };
            var xenos = new WarpGroup { Title = new LocId("rmc-ghost-target-window-group-xenos") };
            var others = new WarpGroup { Title = new LocId("rmc-ghost-target-window-group-others") };
            var warpPoints = new WarpGroup { Title = new LocId("rmc-ghost-target-window-group-warp-points"), IsExpandedByDefault = false };

            foreach (var warp in warps)
            {
                var entry = (warp.DisplayName, warp.Entity, warp.IsWarpPoint, warp.DisplayJob);

                if (warp.IsWarpPoint)
                {
                    warpPoints.Warps.Add(entry);
                }
                else
                {
                    var entity = _entityManager.GetEntity(warp.Entity);
                    if (_entityManager.HasComponent<XenoComponent>(entity))
                    {
                        xenos.Warps.Add(entry);
                    }
                    else if (_entityManager.HasComponent<MarineComponent>(entity) && !_entityManager.HasComponent<SurvivorComponent>(entity))
                    {
                        marines.Warps.Add(entry);
                    }
                    else
                    {
                        others.Warps.Add(entry);
                    }
                }
            }

            // Sorting inside groups
            marines.Warps.Sort((a, b) => string.Compare(a.displayName, b.displayName, StringComparison.CurrentCulture));
            xenos.Warps.Sort((a, b) => string.Compare(a.displayName, b.displayName, StringComparison.CurrentCulture));
            others.Warps.Sort((a, b) => string.Compare(a.displayName, b.displayName, StringComparison.CurrentCulture));
            warpPoints.Warps.Sort((a, b) => string.Compare(a.displayName, b.displayName, StringComparison.CurrentCulture));

            // Adding groups in order of priority
            _warpGroups.Add(marines);
            _warpGroups.Add(xenos);
            _warpGroups.Add(others);
            _warpGroups.Add(warpPoints);
        }

        public void Populate()
        {
            ContentContainer.DisposeAllChildren();
            AddContent();
        }

        private void AddContent()
        {
            var spriteSystem = _entityManager.System<SpriteSystem>();
            var mobThreshold = _entityManager.System<MobThresholdSystem>();
            var mobState = _entityManager.System<MobStateSystem>();

            foreach (var group in _warpGroups)
            {
                if (group.Warps.Count == 0)
                    continue;

                var heading = new CollapsibleHeading($"{Loc.GetString(group.Title)} â€” ({group.Warps.Count})");
                heading.StyleBoxOverride = new StyleBoxTexture
                {
                    Texture = spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/Nano/rounded_button.svg.96dpi.png"))),
                    Modulate = group.HeaderColor,
                    PatchMarginTop = 5,
                    PatchMarginBottom = 5,
                    PatchMarginLeft = 5,
                    PatchMarginRight = 5,
                    ContentMarginTopOverride = 2,
                    ContentMarginLeftOverride = 5,
                    ContentMarginRightOverride = 5,
                    ContentMarginBottomOverride = 2,
                    Padding = new Thickness(2)
                };

                // Add hover effect
                heading.OnMouseEntered += _ =>
                {
                    if (heading.StyleBoxOverride is StyleBoxTexture styleBox)
                    {
                        var currentColor = styleBox.Modulate;
                        styleBox.Modulate = new Color(
                            Math.Min(currentColor.R + 0.1f, 1.0f),
                            Math.Min(currentColor.G + 0.1f, 1.0f),
                            Math.Min(currentColor.B + 0.1f, 1.0f),
                            currentColor.A
                        );
                    }
                };

                heading.OnMouseExited += _ =>
                {
                    if (heading.StyleBoxOverride is StyleBoxTexture styleBox)
                    {
                        styleBox.Modulate = group.HeaderColor;
                    }
                };

                var body = new CollapsibleBody
                {
                    HorizontalExpand = true
                };

                var groupContainer = new GridContainer
                {
                    HorizontalExpand = true,
                    VerticalExpand = true
                };

                body.OnResized += () =>
                {
                    if (body.Width > 0)
                        groupContainer.MaxGridWidth = body.Width;
                };

                foreach (var (name, warpTarget, isWarpPoint, job) in group.Warps)
                {
                    var buttonContainer = new BoxContainer
                    {
                        Orientation = BoxContainer.LayoutOrientation.Horizontal,
                        HorizontalAlignment = Control.HAlignment.Center,
                        VerticalAlignment = Control.VAlignment.Center,
                        HorizontalExpand = true
                    };

                    float? healthPercent = null;

                    if (!isWarpPoint)
                    {
                        var entity = _entityManager.GetEntity(warpTarget);

                        // Adding a Health Icon
                        if (!mobState.IsDead(entity))
                        {
                            // Getting health percent
                            if (_entityManager.TryGetComponent<DamageableComponent>(entity, out var damageable) &&
                                _entityManager.TryGetComponent<MobThresholdsComponent>(entity, out var thresholds))
                            {
                                if (mobThreshold.TryGetThresholdForState(entity, MobState.Dead, out var deadThreshold, thresholds))
                                {
                                    var maxHealth = deadThreshold.Value;
                                    var currentHealth = maxHealth - damageable.TotalDamage;
                                    healthPercent = (currentHealth / maxHealth).Float() * 100f;

                                    string healthIconPath;
                                    if (healthPercent >= 80)
                                        healthIconPath = "/Textures/_RMC14/Interface/health_hud.rsi/health_high.png";
                                    else if (healthPercent >= 40)
                                        healthIconPath = "/Textures/_RMC14/Interface/health_hud.rsi/health_medium.png";
                                    else
                                        healthIconPath = "/Textures/_RMC14/Interface/health_hud.rsi/health_low.png";

                                    var healthIcon = new TextureRect
                                    {
                                        HorizontalAlignment = Control.HAlignment.Center,
                                        VerticalAlignment = Control.VAlignment.Center,
                                        Texture = spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath(healthIconPath))),
                                        Stretch = TextureRect.StretchMode.KeepAspectCentered,
                                        MinSize = new Vector2(13, 13),
                                        MaxSize = new Vector2(13, 13),
                                        Margin = new Thickness(0, 0, 4, 0)
                                    };
                                    buttonContainer.AddChild(healthIcon);
                                }
                            }
                        }

                        // Adding a Job Icon (if it exists)
                        if (_entityManager.TryGetComponent<TacticalMapIconComponent>(entity, out var icon) && icon.Icon != null)
                        {
                            var iconPanel = new PanelContainer
                            {
                                Margin = new Thickness(0, 0, 4, 0)
                            };

                            if (icon.Background != null)
                            {
                                var backgroundView = new TextureRect
                                {
                                    HorizontalAlignment = Control.HAlignment.Center,
                                    VerticalAlignment = Control.VAlignment.Center,
                                    Texture = spriteSystem.Frame0(icon.Background),
                                    Stretch = TextureRect.StretchMode.KeepAspectCentered,
                                    MinSize = new Vector2(16, 16),
                                    MaxSize = new Vector2(16, 16)
                                };
                                iconPanel.AddChild(backgroundView);
                            }

                            var iconView = new TextureRect
                            {
                                HorizontalAlignment = Control.HAlignment.Center,
                                VerticalAlignment = Control.VAlignment.Center,
                                Texture = spriteSystem.Frame0(icon.Icon),
                                Stretch = TextureRect.StretchMode.KeepAspectCentered,
                                MinSize = new Vector2(16, 16),
                                MaxSize = new Vector2(16, 16)
                            };
                            iconPanel.AddChild(iconView);

                            buttonContainer.AddChild(iconPanel);
                        }
                    }

                    var label = new Label
                    {
                        Text = name,
                        HorizontalAlignment = Control.HAlignment.Left,
                        // We prevent buttons from inflating the column to width and allow more to fit on a single line.
                        // If ss14 had something like WrapPanel - a smart container with auto-wrapping of elements,
                        // I would use it, but I don't have the strength and knowledge to build an auto-wrapping architecture.
                        ClipText = false,
                        Name = job != null ? $"{name} {job}" : name, // Saving full name for search
                        StyleClasses = { "LabelSmall" } // Adding a style for a smaller font
                    };
                    buttonContainer.AddChild(label);

                    // Adding a ghost counter
                    if (!isWarpPoint)
                    {
                        var followerSystem = _entityManager.System<FollowerSystem>();
                        var entity = _entityManager.GetEntity(warpTarget);
                        var followerCount = followerSystem.GetFollowerCount(entity);
                        if (followerCount > 0)
                        {
                            var ghostCounter = new BoxContainer
                            {
                                Orientation = BoxContainer.LayoutOrientation.Horizontal,
                                HorizontalAlignment = Control.HAlignment.Right,
                                VerticalAlignment = Control.VAlignment.Center,
                            };

                            var ghostIcon = new TextureRect
                            {
                                HorizontalAlignment = Control.HAlignment.Center,
                                VerticalAlignment = Control.VAlignment.Center,
                                Texture = spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath("/Textures/Mobs/Ghosts/ghost_human.rsi/icon.png"))),
                                Stretch = TextureRect.StretchMode.KeepAspectCentered,
                                MinSize = new Vector2(17, 17),
                                MaxSize = new Vector2(17, 17),
                            };
                            ghostCounter.AddChild(ghostIcon);

                            var ghostCount = new Label
                            {
                                Text = followerCount.ToString(),
                                HorizontalAlignment = Control.HAlignment.Center,
                                VerticalAlignment = Control.VAlignment.Center
                            };
                            ghostCounter.AddChild(ghostCount);

                            buttonContainer.AddChild(ghostCounter);
                        }
                    }

                    var button = new Button
                    {
                        Name = job != null ? $"{name} {job}" : name // Saving full name for search
                    };

                    // Adding a tooltip
                    if (!isWarpPoint)
                    {
                        var entity = _entityManager.GetEntity(warpTarget);
                        var tooltipText = $"{Loc.GetString("rmc-ghost-target-window-tooltip-name", ("name", name))}\n";
                        if (job != null)
                        {
                            // Checking if this is a xenomorph through the component
                            var isXeno = _entityManager.HasComponent<XenoComponent>(entity);
                            tooltipText += isXeno ? $"{Loc.GetString("rmc-ghost-target-window-tooltip-caste", ("caste", job))}" : $"{Loc.GetString("rmc-ghost-target-window-tooltip-job", ("job", job))}";
                        }
                        if (!mobState.IsDead(entity) && healthPercent != null)
                        {
                            tooltipText += $"\n{Loc.GetString("rmc-ghost-target-window-tooltip-health", ("health", Math.Round(healthPercent.Value)))}";
                        }
                        button.ToolTip = tooltipText;
                    }

                    button.AddChild(buttonContainer);

                    button.OnPressed += _ => WarpClicked?.Invoke(warpTarget);
                    button.Visible = ButtonIsVisible(button);

                    groupContainer.AddChild(button);
                }

                body.AddChild(groupContainer);

                var collapsible = new Collapsible(heading, body)
                {
                    Margin = new Thickness(0, 4),
                    HorizontalExpand = true
                };

                // Open the accordion
                if (group.IsExpandedByDefault)
                    collapsible.BodyVisible = true;

                ContentContainer.AddChild(collapsible);
                _collapsibleGroups[collapsible] = group;
            }
        }

        private bool ButtonIsVisible(Button button)
        {
            if (string.IsNullOrEmpty(_searchText))
                return true;

            return button.ChildrenContainText(_searchText) ||
                   (button.Name != null && button.Name.Contains(_searchText, StringComparison.OrdinalIgnoreCase));
        }

        private void UpdateVisibleButtons()
        {
            foreach (var collapsible in ContentContainer.Children.OfType<Collapsible>())
            {
                var body = collapsible.GetChild(1) as CollapsibleBody;
                if (body?.ChildCount != 1)
                    continue;

                var groupContainer = body.GetChild(0) as GridContainer;
                if (groupContainer == null)
                    continue;

                foreach (var button in groupContainer.Children.OfType<Button>())
                {
                    button.Visible = ButtonIsVisible(button);
                }
            }
        }


        private void UpdateVisibleCollapsibles()
        {
            foreach (var child in ContentContainer.Children)
            {
                if (child is Collapsible collapsible)
                {
                    var body = collapsible.GetChild(1) as CollapsibleBody;
                    var container = body?.GetChild(0) as GridContainer;
                    var hasVisibleButtons = container?.Children.OfType<Button>().Any(b => ButtonIsVisible(b)) ?? false;

                    collapsible.Visible = hasVisibleButtons;

                    if (_collapsibleGroups.TryGetValue(collapsible, out var group))
                    {
                        collapsible.BodyVisible = string.IsNullOrEmpty(_searchText)
                            ? group.IsExpandedByDefault
                            : hasVisibleButtons;
                    }
                }
            }
        }

        private void OnSearchTextChanged(LineEdit.LineEditEventArgs args)
        {
            _searchText = args.Text;

            UpdateVisibleButtons();
            UpdateVisibleCollapsibles();
            // Reset scroll bar so they can see the relevant results.
            GhostScroll.SetScrollValue(Vector2.Zero);
        }
    }
}
